name: K8s E2E Test Pipeline

on:
  push:
    branches:
      - main

jobs:
  e2e-test:
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Minikube and kubectl
        run: |
          set -euxo pipefail
          OS_TYPE=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH_TYPE=$(uname -m)
          if [[ "${ARCH_TYPE}" == "aarch64" ]]; then
              ARCH_TYPE="arm64"
          fi
          MINIKUBE_BINARY="minikube-${OS_TYPE}-${ARCH_TYPE}"
          KUBECTL_BINARY="kubectl"
          echo "Detected OS: ${OS_TYPE}, Architecture: ${ARCH_TYPE}"
          echo "Attempting to download Minikube as: ${MINIKUBE_BINARY}"
          echo "Downloading Minikube..."
          curl -LO "https://storage.googleapis.com/minikube/releases/latest/${MINIKUBE_BINARY}"
          echo "Moving Minikube to /usr/local/bin and making it executable..."
          sudo mv "${MINIKUBE_BINARY}" /usr/local/bin/minikube
          sudo chmod +x /usr/local/bin/minikube
          echo "Downloading kubectl..."
          KUBECTL_DOWNLOAD_URL="https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/${OS_TYPE}/${ARCH_TYPE}/${KUBECTL_BINARY}"
          curl -LO "${KUBECTL_DOWNLOAD_URL}"
          echo "Moving kubectl to /usr/local/bin and making it executable..."
          sudo mv "${KUBECTL_BINARY}" /usr/local/bin/kubectl
          sudo chmod +x /usr/local/bin/kubectl
          echo "Verifying Minikube and kubectl installations..."
          ls -l /usr/local/bin/minikube
          file /usr/local/bin/minikube
          minikube version
          ls -l /usr/local/bin/kubectl
          file /usr/local/bin/kubectl
          kubectl version --client

      - name: Setup K8s Environment (Minikube & Deploy Apps)
        run: |
          #!/bin/bash
          set -euxo pipefail
          minikube delete || true
          minikube start --driver=docker
          eval $(minikube docker-env)
          make
          sleep 10
          NAMESPACE_DATE=$(date +%Y%m%d)
          NAMESPACE_RAND=$(shuf -i 1000-9999 -n 1)
          DYNAMIC_NAMESPACE="test-env-${NAMESPACE_DATE}-${NAMESPACE_RAND}"
          echo "Creating namespace: ${DYNAMIC_NAMESPACE}"
          kubectl create ns "${DYNAMIC_NAMESPACE}" || true

          # Export the DYNAMIC_NAMESPACE so subsequent steps can use it (if needed)
          echo "DYNAMIC_NAMESPACE=${DYNAMIC_NAMESPACE}" >> $GITHUB_ENV

          # --- IMPORTANT: Substitute the dynamic namespace into your YAML files ---
          # This command finds all .yaml, .yml, and .json files in ./k8s/test-env/
          # and replaces the placeholder __DYNAMIC_NAMESPACE__ with the actual value.
          # It uses a temporary file for sed to work correctly on macOS and Linux.
          find ./k8s/test-env/ -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) -print0 | while IFS= read -r -d $'\0' file; do
            echo "Substituting namespace in: $file"
            sed -i.bak "s|__DYNAMIC_NAMESPACE__|${DYNAMIC_NAMESPACE}|g" "$file"
            rm "${file}.bak" # Clean up the backup file created by sed
          done
          # ---------------------------------------------------------------------

          echo "Applying datalake application manifests from local path to namespace: ${DYNAMIC_NAMESPACE}..."
          # Now apply the modified files. No need to specify -n here as it's in the YAML.
          # If you have subdirectories and want to apply recursively, add -R here.
          kubectl apply -f ./k8s/test-env/

          echo "Setup complete!"
        env:
          KUBECONFIG: ~/.kube/config

      - name: Run E2E Tests
        run: |
          echo 'test'

      - name: Teardown Minikube Cluster
        if: always()
        run: minikube delete
