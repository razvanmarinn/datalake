name: K8s Tests Pipeline

on:
  push:
    branches:
      - main

jobs:
  run-test:
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Minikube and kubectl
        run: |
          set -euxo pipefail
          OS_TYPE=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH_TYPE=$(uname -m)
          if [[ "${ARCH_TYPE}" == "aarch64" ]]; then
            ARCH_TYPE="arm64"
          fi

          if command -v minikube &> /dev/null && command -v kubectl &> /dev/null; then
              echo "[INFO] Minikube and kubectl are already installed."
              minikube version
              kubectl version --client
              exit 0
          fi

          echo "[INFO] Downloading Minikube and kubectl..."
          MINIKUBE_BINARY="minikube-${OS_TYPE}-${ARCH_TYPE}"
          curl -LO "https://storage.googleapis.com/minikube/releases/latest/${MINIKUBE_BINARY}"
          sudo mv "${MINIKUBE_BINARY}" /usr/local/bin/minikube
          sudo chmod +x /usr/local/bin/minikube

          KUBECTL_URL="https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/${OS_TYPE}/${ARCH_TYPE}/kubectl"
          curl -LO "${KUBECTL_URL}"
          sudo mv "kubectl" /usr/local/bin/kubectl
          sudo chmod +x /usr/local/bin/kubectl

          echo "[INFO] Installation complete."
          minikube version
          kubectl version --client

      - name: Setup K8s Environment (Minikube & Deploy Apps)
        run: |
          set -euxo pipefail

          echo "[INFO] Cleaning up any previous Minikube instance..."
          minikube delete || true

          echo "[INFO] Starting Minikube..."
          minikube start --driver=docker

          # Wait for Minikube to be ready
          echo "[INFO] Waiting for Minikube to be ready..."
          minikube status

          # Set up kubectl context explicitly
          echo "[INFO] Setting up kubectl context..."
          kubectl config use-context minikube
          kubectl cluster-info

          # Verify connection
          echo "[INFO] Verifying kubectl connection..."
          kubectl get nodes

          eval $(minikube docker-env)

          echo "[INFO] Building Docker images locally with make..."
          make

          NAMESPACE_DATE=$(date +%Y%m%d)
          DYNAMIC_NAMESPACE="test-env-${NAMESPACE_DATE}-${RANDOM}"
          echo "Creating namespace: ${DYNAMIC_NAMESPACE}"
          kubectl create ns "${DYNAMIC_NAMESPACE}"
          echo "DYNAMIC_NAMESPACE=${DYNAMIC_NAMESPACE}" >> $GITHUB_ENV

          echo "[INFO] Replacing __DYNAMIC_NAMESPACE__ placeholders in manifests..."
          find ./k8s/test-env/ -type f \( -name "*.yaml" -o -name "*.yml" \) -print0 | while IFS= read -r -d $'\0' file; do
            sed -i.bak "s|__DYNAMIC_NAMESPACE__|${DYNAMIC_NAMESPACE}|g" "$file"
            rm "${file}.bak"
          done

          echo "[INFO] Applying Kubernetes manifests..."
          kubectl apply -f ./k8s/test-env/

          echo "[INFO] Waiting for deployments to become available..."
          kubectl wait --for=condition=available --timeout=300s deployment --all -n "${DYNAMIC_NAMESPACE}"

          echo "[INFO] Waiting for StatefulSets to be ready (if any)..."
          kubectl rollout status statefulset/kafka -n "${DYNAMIC_NAMESPACE}" --timeout=300s || echo "[WARN] No kafka statefulset found or not needed"

      - name: Expose Services and Get URLs
        id: expose_services
        run: |
          set -euxo pipefail

          echo "[INFO] Verifying kubectl context before exposing services..."
          kubectl config current-context
          kubectl get nodes

          echo "[INFO] Retrying to get URLs for services via Minikube..."

          wait_for_service() {
            local svc=$1
            local url=""

            echo "[INFO] Checking if service $svc exists..."
            kubectl get svc "$svc" -n "${DYNAMIC_NAMESPACE}" || {
              echo "[ERROR] Service $svc does not exist"
              kubectl get svc -n "${DYNAMIC_NAMESPACE}"
              return 1
            }

            echo "[INFO] Checking pods for service $svc..."
            kubectl get pods -n "${DYNAMIC_NAMESPACE}" -l app="$svc" || true

            for i in {1..30}; do
              url=$(minikube service "$svc" -n "${DYNAMIC_NAMESPACE}" --url 2>/dev/null || true)
              if [[ -n "$url" ]]; then
                echo "[INFO] $svc is available at $url"
                echo "$url"
                return
              fi
              echo "[WAIT] Waiting for $svc to become ready... (${i}/30)"

              # Add debugging information
              if [[ $i -eq 5 || $i -eq 15 ]]; then
                echo "[DEBUG] Service status:"
                kubectl describe svc "$svc" -n "${DYNAMIC_NAMESPACE}"
                echo "[DEBUG] Endpoints:"
                kubectl get endpoints "$svc" -n "${DYNAMIC_NAMESPACE}"
                echo "[DEBUG] Pods:"
                kubectl get pods -n "${DYNAMIC_NAMESPACE}" -o wide
              fi

              sleep 2
            done

            echo "[ERROR] $svc did not become ready in time"
            kubectl get pods -n "${DYNAMIC_NAMESPACE}" -o wide || true
            kubectl get svc -n "${DYNAMIC_NAMESPACE}" || true
            kubectl describe svc "$svc" -n "${DYNAMIC_NAMESPACE}" || true
            kubectl get endpoints -n "${DYNAMIC_NAMESPACE}" || true
            exit 1
          }

          IDENTITY_URL=$(wait_for_service identity-service)
          echo "identity_service_url=${IDENTITY_URL}" >> $GITHUB_ENV

          GATEWAY_URL=$(wait_for_service api-gateway)
          echo "api_gateway_url=${GATEWAY_URL}" >> $GITHUB_ENV

        env:
          DYNAMIC_NAMESPACE: ${{ env.DYNAMIC_NAMESPACE }}

      - name: Setup Go environment
        uses: actions/setup-go@v5
        with:
          go-version: "1.22"

      - name: Run Go Integration Tests
        id: go-tests
        run: |
          set -euxo pipefail
          echo "[INFO] Running Go integration tests..."
          cd test/integration
          export IDENTITY_SERVICE_URL=${{ env.identity_service_url }}
          export API_GATEWAY_URL=${{ env.api_gateway_url }}
          go test -v ./...
        env:
          DYNAMIC_NAMESPACE: ${{ env.DYNAMIC_NAMESPACE }}

      - name: Dump Logs on Failure
        if: failure()
        run: |
          echo "--- Tests failed. Dumping Kubernetes state for debugging. ---"
          echo "Current kubectl context:"
          kubectl config current-context || echo "No context set"
          kubectl cluster-info || echo "Cluster info failed"

          echo "Minikube status:"
          minikube status || echo "Minikube status failed"

          echo "Pods in namespace:"
          kubectl get pods -n "${DYNAMIC_NAMESPACE}" -o wide || true

          echo "Pod descriptions:"
          kubectl describe pods -n "${DYNAMIC_NAMESPACE}" || true

          echo "Pod logs:"
          kubectl get pods -n "${DYNAMIC_NAMESPACE}" -o name | while read pod; do
            echo "=== Logs for $pod ==="
            kubectl logs "$pod" -n "${DYNAMIC_NAMESPACE}" --tail=50 || true
          done

          echo "Services:"
          kubectl get svc -n "${DYNAMIC_NAMESPACE}" || true

          echo "Endpoints:"
          kubectl get endpoints -n "${DYNAMIC_NAMESPACE}" || true

          echo "Deployments:"
          kubectl get deployment -n "${DYNAMIC_NAMESPACE}" || true

          echo "StatefulSets:"
          kubectl get statefulset -n "${DYNAMIC_NAMESPACE}" || true

          echo "Events:"
          kubectl get events -n "${DYNAMIC_NAMESPACE}" --sort-by='.lastTimestamp' || true
        env:
          DYNAMIC_NAMESPACE: ${{ env.DYNAMIC_NAMESPACE }}

      - name: Teardown Minikube Cluster
        if: always()
        run: |
          echo "[INFO] Cleaning up Minikube cluster..."
          minikube delete || true
